\chapter{Resolución del trabajo}


En este apartado se expondrán tanto los métodos utilizados para la planificación del 
desarrollo del videojuego como la implementación del mismo.  

\section{Planificación y presupuesto}
WIP (AQUI PONER LAS HORAS ESTIMADAS)

\subsection{Planificación inicial}
WIP

\subsection{Presupuesto}
WIP

\section{Análisis y diseño}

A continuación se va a tratar el análisis del proyecto planteado y su respectivo diseño.

\subsection{Especificación de requisitos}

\subsubsection{Requisitos funcionales}

%Lista de requisitos funcionales
\begin{enumerate}
    \item[\textbf{RF-1}] Control del personaje.
    \begin{enumerate}
        \item[\textbf{RF-1.1}] El personaje tendrá un set de movimientos y acciones básicos.
        \begin{enumerate}
            \item[\textbf{RF-1.1.1}] El personaje podrá caminar hacia cualquier dirección para poder desplazarse por el entorno.
            \item[\textbf{RF-1.1.2}] El personaje tendrá una serie de  movimientos de ataque para derrotar a los enemigos que encuentre.
            \item[\textbf{RF-1.1.3}] El personaje tendrá la capacidad de poder cortar elementos del entorno.
        \end{enumerate}
        \item[\textbf{RF-1.2}] El jugador deberá poder controlar los movimientos del personaje.
        \item[\textbf{RF-1.3}] El jugador tiene que poder controlar las acciones del personaje.
        \item[\textbf{RF-1.4}] El videojuego se deberá poder controlar tanto con mando como teclado y ratón.
    \end{enumerate}
    \item[\textbf{RF-2}] Comportamiento del entorno.
    \begin{enumerate}
        \item[\textbf{RF-2.1}] El sistema generará una partida completamente nueva y distinta a la anterior cada vez que se inicie un nuevo juego.
        \begin{enumerate}
            \item[\textbf{RF-2.1.1}] Las mazmorras se generarán de manera aleatoria para evitar que el videojuego se vuelva repetitivo.
            \item[\textbf{RF-2.1.2}] Los enemigos de las mazmorras se generarán en patrones distintos y en salas distintas.
            \item[\textbf{RF-2.1.3}] Las recompensas o mejoras para el jugador aparecerán en situaciones aleatorias.
        \end{enumerate}
        \item[\textbf{RF-2.2}] El sistema generará a los enemigos que serán agentes reactivos.
        \item[\textbf{RF-2.3}] El sistema generará a los enemigos serán de distintos tipos y cada tipo tendrá su propio comportamiento.
        \item[\textbf{RF-2.4}] El sistema generará recompensas y mejoras para el jugador. 
        \begin{enumerate}
            \item[\textbf{RF-2.4.1}] Las recompensas serán de varios tipos.
            \begin{enumerate}
                \item[\textbf{RF-2.4.1.1}] El sistema generará recompensas que mejoren el daño provocado a los enemigos.
                \item[\textbf{RF-2.4.1.2}] El sistema generará recompensas que mejoren la resistencia del jugador.
            \end{enumerate}
        \end{enumerate}
        \item[\textbf{RF-2.5}]El sistema generará mazmorras que tendrán distintos tipos de salas.
        \begin{enumerate}
            \item[\textbf{RF-2.5.1}] El sistema generará salas con enemigos las cuales no se desbloquearán hasta derrotar a todos.
            \item[\textbf{RF-2.5.2}] El sistema generará salas con recompensas. 
            \item[\textbf{RF-2.5.3}] El sistema generará salas con un enemigo tipo jefe que presentará un mayor desafío para el jugador. 
        \end{enumerate}
        \item[\textbf{RF-2.6}] El sistema será capaz de reproducir sonidos acordes a lo sucedido en el videojuego.
    \end{enumerate}
    \item[\textbf{RF-3}] Control sobre el sistema
    \begin{enumerate}
        \item[\textbf{RF-3.1}] El jugador podrá empezar una partida.
        \item[\textbf{RF-3.2}] El jugador podrá guardar una partida.
        \item[\textbf{RF-3.3}] El jugador podrá abandonar una partida.
        \item[\textbf{RF-3.4}] El jugador podrá pausar la partida.
        \item[\textbf{RF-3.5}] El jugador deberá ser capaz de cambiar distintos parámetros del sistema.
        \begin{enumerate}
            \item[\textbf{RF-3.5}]  El jugador deberá ser capaz de ajustar el nivel de sonido.
            \item[\textbf{RF-3.6}]  El jugador deberá ser capaz de ajustar la resolución de pantalla.
        \end{enumerate} 
    \end{enumerate}
\end{enumerate}

\subsubsection{Requisitos no funcionales}


\subsection{Material importado}

Como en este proyecto la intención ha sido desde el principio centrarse en la parte técnica del desarrollo
del videojuego, los diseños y modelos utilizados en su mayoría han sido importados de webs las cuales
ofrecen modelos con licencia \textit{Creative Commons} para uso libre. A continuación se mostraran los modelos utilizados 
y de donde se han obtenido.\\
Para este proyecto serán necesarios bastantes elementos los cuales son:
%Aqui tengo que poner también ademásd del personaje, los muebles, enemigos, armas y decorados que use.

\subsubsection{Personaje principal}
Este modelo ha sido importado desde la web de \textit{Adobe Mixamo} \cite{Mixamo} la cual ofrece una gran cantidad de modelos 3D
y animaciones, la gran mayoría compatibles con \textit{Unity}. Debido a el contexto en el que se quiere situar
el videojuego, el modelo elegido es una especie de androide humanoide futurista. Dado que es algo que no se va a tener en cuenta a la hora de
jugar, el personaje principal no será personalizable, siempre tendrá este aspecto. \\
A continuación imagen del modelo elegido: 

\begin{figure}[htbp]
\centering
\includegraphics[width=8cm, height=8cm]{characterModel.jpg}
\caption{Modelo Alien Soldier}
\end{figure}

Un aspecto bastante interesante de este modelo es que es \textit{rigged}, es decir, que incluye
un esqueleto con el que a la hora de añadir las distintas animaciones al personaje, se va a facilitar bastante dicha tarea. \\

Para animar este modelo se han importado también una serie de animaciones, también de la web
\textit{Mixamo}. Dichas animaciones abarcan movimientos como caminar, correr, saltar y atacar.

\subsubsection{Armas}
En esta sección se mostraran los modelos de armas utilizados por el personaje principal y enemigos del videojuego

La espada del personaje principal, es una \textit{katana} la cual se importó desde la web de 
\textit{Sketchfab} \cite{Sketchfab} que ofrece gran cantidad de Assets y modelos 3D tanto gratis como de pago.
Este modelo seleccionado es gratuito y fue creado por el usuario shor.riot. \\

Se eligió este tipo de arma ya que es bien conocido
que las katanas japonesas tienen fama de ser muy afiladas y por tanto, para un aspecto importante del videojuego 
(el modo Ultra en el que el personaje será capaz de cortar con su katana a los enemigos y elementos que tenga delante) es ideal que sea esta arma, y se
ha escogido este modelo en concreto ya que con la luz neón verde que incluye la textura del modelo,
da la sensación de ser una katana más futurista y así adaptarse mejor al contexto del videojuego. A continuación se muestra el modelo
de dicha katana: 

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=8cm]{phaseKatana.jpg}
    \caption{Modelo 3D Phase Katana}
\end{figure}

\subsubsection{Enemigos}

Los modelos de los enemigos han sido importados desde una página web la cual es la que más elementos ha proporcionado al proyecto, dicha página es \textit{Unity Asset Store} \cite{UnityAssetStore}. Según la propia página de documentación oficial proporcionada por Unity, la \textit{Unity Documentation} \cite{UnityDocumentation} este servicio es una plataforma en línea donde los desarrolladores de videojuegos pueden encontrar y adquirir una amplia variedad de activos, recursos y herramientas para usar en sus proyectos de Unity. Estos activos pueden incluir modelos 3D, texturas, scripts, paquetes de efectos visuales, música, sonidos, plantillas de interfaz de usuario y mucho más.

Unity Asset Store proporciona a los desarrolladores una forma conveniente de expandir y mejorar sus juegos al ofrecer una amplia selección de contenido creado por otros desarrolladores. Los activos se pueden comprar o descargar de forma gratuita, dependiendo de las preferencias del creador del activo. Además, también existe la opción de adquirir paquetes completos que contienen varios activos relacionados, en este caso, este paquete es gratuito e incluye todo lo necesario para la funcionalidad que se quiere hacer.

El paquete de modelos 3D, texturas y animaciones de los enemigos es \textit{SciFi Enemies and Vehicles} del usuario \textit{Popup Asylum}. Dicho paquete fue de gran utilidad y calidad pese a ser gratuito. El modelo 3D usado para el enemigo de tipo \textit{Melee} o ataque a corta distancia, es una especie de escorpión robótico, llamado por el autor como \textit{Warrior}. A continuación imagen de dicho modelo.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm, height=8cm]{MeleeEnemy.jpg}
    \caption{Modelo 3D enemigo Melee Warrior}
\end{figure}

Las animaciones de este enemigo también están incluidas en el paquete. Las que se han usado han sido animaciones de patrullar, correr, observar y atacar.

\subsubsection{Decoración}

Otro aspecto importante de los videojuegos es el propio mapa y los elementos que lo decoran, esto sirve para poder acercar lo máximo posible al usuario 
el entorno o historia que se quiere transmitir. Para ello hay que diferenciar entre los distintos elementos que conforman el concepto de decoración.

Lo primero de lo que hablaremos será de la \textbf{Skybox} del entorno. De acuerdo con la \textit{Unity Documentation} una skybox es una envoltura alrededor de la escena que muestra cómo se ve el mundo más allá de su geometría. Es decir, es el paisaje de fondo que existe en el videojuego, además de los elementos 3D, es necesario una skybox para conseguir la sensación de estar dentro de un mundo inventado por el creador del videojuego.\\

Para las skybox normalmente se usan  \textit{Cubemap} \cite{Cubemaps} las cuales son una representación especial de una textura en forma de cubo en tres dimensiones. Consiste en seis texturas 2D separadas que se unen para formar un cubo completo. Cada una de las seis caras del cubo representa una vista diferente del entorno y además cada una de las caras tienen las mismas dimensiones. A continuación un ejemplo de dicho tipo de imágenes.\\

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=8cm]{cubemapExample.png}
    \caption{Ejemplo de Cubemap usado para una Skybox}
\end{figure}

Sin embargo en mi caso se ha utilizado otra variante también muy usada, la cual se trata de las \textit{Equirectangular Images} \cite{EquirectangularImages}. Se trata una imagen 2D que se envuelve alrededor de una esfera, proporcionando un campo de visión horizontal de 360 grados y un campo de visión vertical de 180 grados. Este tipo de proyección se utiliza comúnmente para imágenes panorámicas y ofrece una forma conveniente de capturar y mostrar una vista de gran angular de un entorno, como por ejemplo el típico mapa de La Tierra.
Una vez explicado este concepto, pasamos a explicar la creación de la Skybox usada en el proyecto, puesto que es una imagen única producida por una inteligencia artifical generativa. Esta herramienta se encuentra en la web y está en desarrollo, se trata de \textit{Blockade Labs} \cite{BlockadeLabs}, una web que ofrece de forma gratuita una IA generativa, la cual, a partir de inputs de texto y opciones seleccionables, es capaz de generar Skyboxes ciñendose a dichos inputs. Pues de esta manera se generó la skybox para el proyecto, a continuación se muestra dicha imagen equirectangular.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{skybox.jpg}
    \caption{Skybox generada por IA y usada en el proyecto}
\end{figure}

Como se puede observar, se eligió un concepto futurista y en entorno nocturno para generar dicha imagen, ya que se ajusta bien a el objetivo y contexto del videojuego.\\

Siguiendo con el decorado de los escenarios, se buscaron elementos que pudieran encajar en la temática. Se decidió buscar en la ya mencionada \textit{Unity Asset Store} y se encontró un paquete con una gran cantidad de modelos de decorado 3D, y que además encajaban con la temática \textit{SciFi}. Este paquete es \textbf{Low Poly Sci Fi Set} del usuario \textbf{Walter Palladino}. De este paquete se han usado 6 elementos de decoración, como son cajas de distinto tamaño y forma, así como de 2 cápsulas de cristal, una rota y otra en buen estado. Estos elementos están escogidos para que además el jugador pueda cortarlos con la mecánica del \textbf{Modo Ultrasónico} ya que a veces estos elementos bloquearán el camino y el jugador deberá abrirse paso cortándolos.
Estos elementos se muestran a continuación.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{caja1.jpg}
    \caption{Modelo 3D caja con una línea en medio color verde}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{caja2.jpg}
    \caption{Modelo 3D de cubo simple}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{caja3.jpg}
    \caption{Modelo 3D de caja con 3 líneas de decoración color verde}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{caja5.jpg}
    \caption{Modelo 3D de caja rectangular con una línea de color verde}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{capsulas.jpg}
    \caption{Modelos 3D de capsulas de cristal, una rota y otra en buen estado}
\end{figure}

Se importaron de otro paquete otros 2 elementos más de decoración, ampliando hasta 8, el total de elementos que conforman el decorado del videojuego. El paquete se llama \textbf{LowPoly Server Room Props} del usuario \textbf{iPoly3D}.

A continuación imagenes de los 2 modelos seleccionados.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{caja4.jpg}
    \caption{Modelo 3D de caja rectangular con adornos en la parte delantera}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{panel.jpg}
    \caption{Modelo 3D de panel de mandos}
\end{figure}

Por último, también se ha añadido decorado para el propio personaje, se trata de otro modelo de katana distinto al mencionado anteriormente, y se va a incluir en esta sección ya que su uso va a ser puramente estético, no va a ser un arma funcional dentro del videojuego. Este modelo también ha sido descargado e importado desde \textit{Unity Assets Store}, se trata de un modelo de katana 3D junto con la funda de la misma. El paquete se llama \textbf{Free Katana and Scabbard} de el usuario \textbf{Hideout Studio}.\\

Dicha funda y katana se han añadido en la cintura del personaje, el proceso seguido para conseguir que la katana esté ceñida a la cintura del personaje será explicado más adelante en la sección de Implementacion. A continuación el modelo mencionado:

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{modeloKatana2.jpg}
    \caption{Katana y funda 3D importada para mejorar el aspecto del personaje principal}
\end{figure}

\subsubsection{Coleccionables}

Para los objetos coleccionables que el jugador podrá recoger por el escenario, se han importado también de \textit{Unity Asset Store}. El paquete es \textbf{Ten Power-Ups} del usuario \textbf{TeKniKo}, y dicho paquete incluye numerosos iconos y modelos prefabricados de coleccionables, además de un Script que produce el efecto de flotar en el aire. Los coleccionables usados de dicho paquete han sido, una estrella la cual al recogerla se acaba la partida y el jugador gana, unas flechas verdes apuntando hacia arriba indicando mejora de daño, y un icono de una cruz roja para curar la salud del jugador.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{powerUps.jpg}
    \caption{Coleccionables usados en el proyecto, estrella, flechas verdes y cruz roja}
\end{figure}


\subsubsection{Sonidos}

Los sonidos usados en el proyecto, han sido obtenidos de la plataforma \textit{YouTube} \cite{YouTube}. Todos los sonidos y la música obtenida es de uso libre y no tienen licencias de \textit{Copyright}.\\

De sonidos de efectos especiales se han importado los siguientes: 
\begin{itemize}
    \item[\textbf{Correr}] Este sonido se ha obtenido del vídeo llamado \textbf{RUN / RUNNING SOUND EFFECT | FOOTSTEPS SOUND [High Quality]} del usuario \textbf{LISTEN}, y este sonido se ha usado para el efecto especial del personaje cuando realiza la acción de correr.
    \item[\textbf{Corte de Katana}] Sonido conseguido del vídeo \textbf{Katana Swing Cut - Sound Effect for editing} del usuario textbf{Sound library}, usado cuando el jugador realiza un corte con la katana a un objeto.
    \item[\textbf{Espadazo}] El vídeo de donde se ha sacado se llama \textbf{sword slash (sound effects) || mani creation ||} del usuario \textbf{Become a better you}. Para este sonido he tenido que recortarlo ya que en la misma pista de audio había muchos más efectos.
    \item[\textbf{Cámara lenta}] Sonido usado para indicar al jugador, además de forma visual, de forma auditiva que ha entrado en \textit{Modo Ultrasónico}. El vídeo de donde se ha obtenido el efecto es \textbf{Slow Motion Sound Effect} del usuario \textbf{SFX Sounds}. Este efecto también ha habido que recortarlo ya que vienen juntos en la misma pista varios efectos.
    \item[\textbf{Power Up}] Efecto de recoger un power up o coleccionable. Vídeo \textbf{Power-Up - Sound Effect (HD)} del usuario \textbf{House Of Sound Effects}.
    \item[\textbf{Música partida}] Esta canción suena de fondo mientras transcurre la partida, como ya se ha mencionado antes es música sin licencias de \textit{Copyright}. \textbf{Sci Fi Cyberpunk - VHS [Synthwave/Electro]} del usuario \textbf{The Neon World}.
    \item[\textbf{Música Menú }] Canción que suena durante el tiempo que el jugador esté en el menú principal, se ha obtenido del vídeo \textbf{Synthwave Game Boy by Infraction [No Copyright Music] / Cassette} y el usuario que lo proporciona es \textbf{Infraction - No Copyright Music}
    \item[\textbf{Música victoria}] Esta música sonará cuando el jugador recoja el coleccionable con el que se acaba la partida, se ha descargado desde el vídeo \textbf{Edge of Tomorrow - Synthwave - Royalty Free Music} del usuario \textbf{TeknoAXE's Royalty Free Music}.  
\end{itemize}

\subsection{Descripción detallada del proyecto }

A la hora de hablar del desarrollo del proyecto, es posible realizar una distinción entre
 distintas partes del proyecto y pasar a su explicación de forma separada, ya que cada una de estas 
 partes abarca herramientas y enfoques distintos. Más adelante en la sección de implementación se abarcarán los detalles técnicos de cada sección.

\subsubsection{Aspectos generales del proyecto}

El proyecto ha sido desarrollado en la versión 2021.3.2f1 \cite{UnityLTS} del editor de Unity, que además es una versión \textit{Long Time Support}, por lo que este ha sido el motivo de usar esta versión.\\

Para el estilo visual que se ha implementado en el proyecto, ha sido necesario utilizar el \textit{Universal Render Pipeline} \cite{URP}. Un \textit{Render Pipeline} \cite{RenderPipeline} o tubería de renderizado, es un conjunto de etapas o procesos que se utilizan en los motores gráficos para convertir datos de geometría y texturas en imágenes visuales finales en tiempo real. En Unity existen 3 render pipelines distintas, prefabricadas, además de que se da la posibilidad al usuario de crear su propia render pipeline si así se prefiere.

En Unity, existen dos sistemas principales de renderizado: el sistema de renderizado incorporado (Built-in Render) y el sistema de renderizado universal (Universal Render Pipeline).

El \textbf{Built-in Render} es el predeterminado en Unity. Proporciona una amplia compatibilidad con diferentes dispositivos y plataformas. Permite utilizar características avanzadas como reflejos en tiempo real, sombras en tiempo real y efectos de postprocesamiento. Sin embargo, puede tener un rendimiento inferior en comparación con los sistemas más optimizados.

El sistema \textbf{URP} (Universal Render Pipeline), está diseñado para ofrecer un rendimiento eficiente en dispositivos móviles y de gama baja. Utiliza un enfoque de sombreado simplificado y un conjunto de características restringido en comparación con el sistema Built-in. A pesar de esto, el URP permite utilizar shaders personalizados, lo cual se ha realizado en este proyecto, efectos de postprocesamiento y efectos visuales de alta calidad mediante su propio sistema de efectos. También incluye herramientas adicionales de optimización, como el culling (desaparición) de objetos, para mejorar el rendimiento. Como ya se ha mencionado, este es el sistema que se ha usado en este proyeto.

Además de estos sistemas principales, Unity también ofrece el \textbf{High Definition Render Pipeline} (HDRP) como una opción avanzada para obtener gráficos de alta calidad en dispositivos de gama alta. El HDRP proporciona características de renderizado fotorrealistas, iluminación global avanzada, sombras de alta calidad y efectos visuales realistas. Lógicamente, esta render pipeline no era conveniente para este proyecto por lo que ni se valoró su uso.

Finalmente, debido a las facilidades y la alta capacidad de personalización y rendimiento que ofrece el URP, se valoró como el más adecuado para el proyecto, sobre todo en el aspecto de diseño de un estilo visual diferenciado.

\subsubsection{Cámara del personaje principal} 

Quizás este es uno de los aspectos más importantes de los videojuegos, la \textbf{cámara} es algo
que puede marcar la diferencia entre un videojuego y otro y por supuesto influye en aspectos como
el tipo de videojuego que se va a realizar o la experiencia del jugador/usuario.\\

Antes de hablar de cómo se ha desarrollado la cámara, se va a explicar muy brevemente los distintos tipos de cámara más usados en los videojuegos a día de hoy: 
\begin{enumerate}
    \item[\textbf{1º persona}] Este tipo de cámara es de los más usados actualmente, consiste en recrear con la cámara 
    que el jugador está viendo lo mismo que el personaje que controla dentro del mismo. Este tipo de cámara sobre todo se plantea en videojuegos realizados en entornos 3D .Esta cámara se suele usar sobretodo en 
    videojuegos tipo \textit{shooter} o de miedo, para conseguir esta inmmersion para el jugador. A continuación un ejemplo de dicho tipo de cámara:
    \begin{figure}[H]
        \centering
        \includegraphics[width=10cm, height=5cm]{doomEjemplo.jpg}
        \caption{Videojuego Doom}
    \end{figure}
    \item[\textbf{3º persona}] Este tipo de cámara pretende dar la sensación al jugador de que está presenciando
    en forma de espectador lo que le ocurre al personaje del videojuego, consiguiendo de esa manera que el usuario
    al jugar lo que está haciendo es interferir en la historia o acciones del personaje que controla. Ejemplo a continuación:
    \begin{figure}[H]
        \includegraphics[width=10cm, height=5cm]{BOTWejemplo.jpg}
        \caption{Videojuego The Legend Of Zelda: Breath of the Wild}
    \end{figure}
    \item[\textbf{Isométrica}] Este tipo de cámara, como su nombre indica, se situa en perspectiva 
    Isométrica con respecto a la escena de forma que se ve como si el usuario estuviera situado en el cielo de la escena presenciandola.
    Este tipo de cámara puede ser parecida a la de 3º persona pero con ella se pueden realizar videojuegos totalmente distintos como por ejemplo videojuegos de estrategia o de construcción de ciudades.
    Ejemplo : 
    \begin{figure}[H]
        \centering
        \includegraphics[width=10cm, height=5cm]{AOE2ejemplo.jpg}
        \caption{Videojuego Age Of Empires II}
    \end{figure}
\end{enumerate}

En el proyecto, se va a implementar una cámara en \textbf{tercera persona}. Una vez vistos los principales tipos de cámara que se usan a día de hoy en los videojuegos, proseguiremos con la explicación
del desarrollo de la cámara de el videojuego que se está tratando.

Para la cámara se ha decidido importar un paquete de \textit{Unity} llamado \textit{Cinemachine} \cite{UnityCinemachine} %Referenciar
el cual proporciona una serie de herramientas para facilitar la creación, la lógica y los parámetros de la cámara 
que se va a usar.
\textit{Cinemachine} facilita el uso de la cámara en \textit{Unity} en comparación con la cámara básica de \textit{Unity}, ya que proporciona una forma más intuitiva y fácil de crear y gestionar la cámara. También permite la creación de efectos de cámara avanzados sin necesidad de escribir código, lo que ahorra tiempo y esfuerzo en el desarrollo del juego o aplicación.

Entre las funcionalidades más destacadas de \textit{Cinemachine} se encuentran:

\begin{enumerate}
\item Seguimiento de objetos: \textit{Cinemachine} permite configurar la cámara para seguir automáticamente un objeto determinado, como un personaje, un vehículo, etc. Además, es posible definir el tipo de seguimiento que se desea (por ejemplo, seguir al objeto en todo momento, o solo cuando se mueve) y ajustar la velocidad y otros parámetros.

\item Composición de cámaras: \textit{Cinemachine} permite crear composiciones de cámaras complejas, que pueden incluir varias cámaras configuradas de diferentes maneras. Esto permite crear efectos interesantes, como transiciones entre cámaras o cambios de perspectiva.

\item Efectos de cámara: \textit{Cinemachine} incluye varios efectos de cámara preconfigurados, como la profundidad de campo, la corrección de color, la desenfoque de movimiento, etc. Estos efectos pueden aplicarse fácilmente a la cámara y ajustarse según las necesidades del juego o aplicación.

\item Curvas de animación: \textit{Cinemachine} permite crear curvas de animación para la cámara y otros elementos del juego, lo que permite crear movimientos suaves y naturales. Además, estas curvas pueden ser editadas de manera visual, lo que facilita su ajuste.

\item Integración con otros sistemas: \textit{Cinemachine} se integra bien con otros sistemas de \textit{Unity}, como el sistema de animación o el sistema de física. Esto permite crear efectos más realistas y dinámicos, como movimientos de cámara que se ajustan automáticamente a la física del juego.

\end{enumerate}

En general, \textit{Cinemachine} es una herramienta muy útil para cualquier desarrollador que quiera crear un sistema de cámara avanzado y dinámico para su juego o aplicación. Ofrece una interfaz gráfica intuitiva, una amplia variedad de funcionalidades y efectos de cámara, y se integra bien con otros sistemas de \textit{Unity}.

De acuerdo pues una vez repasados los aspectos principales de \textit{Cinemachine}, la configuración que se ha hecho en el proyecto ha sido, 
seleccionar un tipo de cámara llamada \textit{FreeLook camera} \cite{CinemachineFreelook}. Esta cámara permite 
\begin{itemize}    
    \item \textbf{Control de tres ejes:} La cámara FreeLook permite controlar la posición y rotación de la cámara en tres ejes: horizontal, vertical y de profundidad. Esto permite crear movimientos de cámara complejos y precisos.
   
    \item \textbf{Modo de seguimiento suave:} La cámara FreeLook puede seguir objetos en movimiento con un modo de seguimiento suave que evita movimientos bruscos y mejora la sensación de realismo.

    \item \textbf{Zonas de enfoque:} Es posible definir zonas de enfoque que indican a la cámara qué objetos o áreas deben mantenerse en foco en todo momento. Esto es especialmente útil en juegos de acción o deportes donde los objetos en movimiento pueden desaparecer de la vista rápidamente.

    \item \textbf{Configuración de prioridades:} La cámara FreeLook permite establecer prioridades entre diferentes objetivos de seguimiento. Esto significa que se pueden definir qué objetos tienen más importancia en la escena y la cámara se enfocará en ellos en caso de conflicto.

    \item \textbf{Distancia de seguimiento ajustable:} Es posible ajustar la distancia de seguimiento de la cámara, lo que permite acercar o alejar la cámara del objeto en movimiento para crear diferentes efectos visuales.

    \item \textbf{Modos de enfoque:} La cámara FreeLook tiene diferentes modos de enfoque que permiten controlar cómo se enfoca la cámara en los objetos de la escena. Por ejemplo, se pueden usar modos de enfoque basados en la distancia o en el ángulo de la cámara.
\end{itemize}

Además de esta cámara se ha configurado otro tipo que incluye el paquete \textit{Cinemachine}, que es \textit{Virtual Camera} \cite{CinemachineVirtualCamera}. Esta cámara se parece a la anterior mencionada \textit{FreeLook} pero tiene algunas diferencias por las cuales se ha elegido dicho tipo para cuando el jugador entre en \textbf{Modo Ultrasónico}. Podemos destacar de las propiedades, de las cuales comparte muchas con la cámara \textit{FreeLook} como puede ser el modo de seguimiento (Follow) o LookAt, además ésta permite crear transiciones suaves de una cámara a otra, evitando cambios bruscos y molestos en el jugador. 

Podemos concluir que la diferencia entre ambas es que la Cinemachine FreeLook camera se especializa en proporcionar un movimiento de cámara más complejo y cinematográfico (movimientos de cámara similares a los de películas de cine). Mientras que la VirtualCamera se centra en el seguimiento y la orientación automática de objetivos además de mayor personalización en el ajuste de la cámara como el ángulo o campo de visión. A continuación imagenes con cada tipo de cámara para compararlas.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{FreeLookCamera.jpg}
    \caption{Ejemplo de FreeLook camera realizando un plano contrapicado al personaje}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{VirtualCamera.jpg}
    \caption{Ejemplo de Virtual camera configurada para simular que tanto el jugador como el personaje estén mirando al centro de la pantalla}
\end{figure}

El Script en Unity
que controla ésta cámara se llama \textit{ThirdPersonCam.cs}, más adelante se verá en detalle el código de dicho script. 
Una vez explicada la cámara y la herramienta utilizada para su desarrollo se procederá a la explicación del siguiente elemento del proyecto.

\subsubsection{Personaje principal}

A la hora de definir los distintos movimientos del personaje principal se han seleccionado una serie 
de animaciones las cuales están sincronizadas con el desplazamiento del personaje, pero vamos a entrar más en detalle para hablar de como se 
ha planteado y desarrollado. Hay que recalcar que las animaciones son un aspecto clave en el desarrollo de videojuegos, pese a que no es el objetivo de este proyecto, se ha cuidado este aspecto todo lo posible durante el desarrollo del proyecto.\\

Lo primero es que se ha hecho es elegir de la web \textit{Unity Asset Store} animaciones de \textit{samurai} japonés, ya que encajaban perfectamente con el planteamiento y las inspiraciones para realizar el proyecto.

 Antes de seguir vamos a definir de forma breve algunos conceptos como el de animación y explicaremos las herramientas con las que se ha realizado este apartado del proyecto. La animación es el proceso de crear la ilusión de movimiento a partir de una secuencia de imágenes estáticas. Se logra mostrando una serie de imágenes en rápida sucesión, cada una ligeramente diferente de la anterior, lo que crea la ilusión de movimiento continuo. Pueden ser dibujos, imágenes generadas por computadora o incluso objetos reales que se mueven cuadro a cuadro. 

 La animación \cite{Animacion} tal y como la conocemos hoy día comenzó cuando los animadores de \textbf{Disney}, \textbf{Ollie Johnston} y \textbf{Frank Thomas}, recogieron en su libro \textit{The Illusion of life} los "Doce principios básicos de la animación" \cite{TheIllusionOfLife}. El objetivo de estos principios era intentar crear la ilusión de que los personajes se apegaban a las leyes de la física aunque se abarcaron también temas como el tiempo emocional y atractivo de los personajes. 

 \begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=8cm]{pelotaRebotando.png}
    \caption{Bola roja rebotando desglosada en 6 fotogramas. Extraido de https://es.wikipedia.org/wiki/Archivo:Animexample3edit.png }
\end{figure}

 Aunque inicialmente se pretendía que estos principios se aplicaran principalmente a la animación tradicional o animación dibujada a mano, siguen siendo de gran relevancia en la actualidad, especialmente en el contexto de la animación por ordenador que prevalece hoy en día.

Una vez repasado el concepto de animación, ahora se da paso a cómo se puede trabajar con las animaciones en Unity. Recalcar que ninguna de las animaciones usadas ha sido creada de cero para este proyecto, todas han sido creadas por otros usuarios. Lo que sí se ha hecho ha sido modificar la velocidas o algunos fotogramas de determinadas animaciones. 

Para aplicar animaciones en Unity es necesario usar el elemento ''Animator'' \cite{AnimatorUnity} el cual es una herramienta que permite controlar y programar animaciones en un objeto 3D. Funciona mediante la creación de ''animators controllers'', que son conjuntos de reglas y estados que controlan la reproducción de animaciones.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm, height=8cm]{AnimatorControllerExample.png}
    \caption{Ejemplo de Animator formando un esquema de animator controllers junto a las reglas que los confroman. Imagen extraida de https://docs.unity3d.com/es/530/Manual/class-AnimatorController.html }
\end{figure}

Primero hablaremos de las animaciones del personaje principal, dicho personaje es de tipo ''rigged''. Cuando se habla de un modelo rigged en el contexto de elementos 3D, se refiere a un modelo tridimensional que ha sido equipado con un esqueleto virtual, también conocido como rig. El rig es una estructura interna compuesta por huesos, articulaciones y controladores que simula el sistema musculoesquelético de un personaje o modelo.

Para que haya animaciones distintas y concurrentes en distintas partes del cuerpo, se puede lograr mediante la creación de ''mecanim animations'' \cite{MecanimAnimation}. Este proceso implica la creación de varios animators controllers que controlan diferentes partes del modelo, y luego combinarlos para crear una animación completa y coherente. En el caso del personaje principal se decidió separar el modelo el tren superior e inferior del cuerpo. A continuación imagen de cada máscara creada para indicar que músculos del modelos responderán a las animaciones. 

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=8cm]{UpperBodyMask.jpg}
    \caption{Animator mask correspondiente a el tren superior del cuerpo del personaje, en verde los músculos que se moverán en cada animación}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=8cm]{LowerBodyMask.jpg}
    \caption{Animator mask correspondiente a el tren inferior del cuerpo del personaje, en verde los músculos que se moverán en cada animación}
\end{figure}

Para poder acceder a cada una de estas máscaras, dentro del Animator hay que crear tantas ''Layers'' o capas como se deseen, en este caso se crearpn 2 layers, una para cada máscara. En cada layer se presenta un diagrama de estados vacío, de forma que se pueden personalizar cada una de las layers al punto que se desee. En el apartado de la implementación se detallarán los diagramas de estados así como la lógica de transición entre ellos.

El movimiento en sí del personaje está creado vía Script y responde a los inputs del jugador a través de teclas o botones de un controlador.

El personaje principal tiene asociado unos parámetros de Salud y de Daño los cuales se gestionan a través de Scripts según se den las condiciones que los activen o no. Por ejemplo al jugador se le bajará la salud cuando reciba un golpe por parte de un enemigo. Todo esto será posible gracias a los \textit{Colliders} que ofrece Unity, con los cuales se puede gestionar cómo interactúan de forma física los distintos elementos de la escena. Así como se ha dotado al personaje de colliders, a los demás elementos también, ya que sin ellos no se podrá conseguir el comportamiento esperado.

Por último, el personaje también interactuará con una serie de elementos coleccionables los cuales, al colisionar con ellos afectarán a los parámetros de Salud y daño del jugador, incrementándolos. Además de un elemento coleccionable encargado de que cuando el juagdor lo recoja, en ese momento se de por finalizada la partida.

\subsection{Enemigo}

El enemigo que el personaje debe derrotar durante el juego tiene una serie de animaciones asociadas y un comportamiento guiado por una máquina de estados sencilla, la cual contempla 4 estados distintos que son, patrulla, vigilancia, aproximación al jugador y ataque al jugador. La lógica de transición entre animaciones o comportamientos se trata a través de parámetros ''Trigger''. 

Las animaciones de estos enemigos no son de tipo rigged ya que los modelos no son humanoides y por tanto no se tratan igual. Además los enemigos tienen asociados unos parámetros de vida y de daño, los cuales se ven afectados por las acciones del jugador.

\subsubsection{Modo Ultrasónico}

El Modo Ultrasónico consiste en un modo al cual podrá acceder el jugador al mantener pulsada Cierta tecla o botón, y durante el cual, el personaje será capaz de cortar los elementos estáticos del entorno, exceptuando enemicos, paredes y suelo. 

Se ha logrado que solo se corte a cierto tipo de elementos del entorno mediante las 'layers' que ofrece Unity, las cuales se pueden crear para indicar a el editor el layer de cada elemento. Hay muchas layers default, pero se ha creado la layer \textit{Enemy} para esto, y se les ha asociado a cada uno de los elementos cortables esta layer. De esta manera, cuando el script con la lógica de corte interactúa con los colliders de elementos en la capa Enemy, corta dichos elementos.

Para limitar la distancia y la orientación de los cortes, se proporciona al jugador durante este modo, de un plano el cual sólo verá cuando esté activado el modo Ultrasónico, y el cual podrá girar para ajustar los cortes como guste el usuario. 

Durante este modo además se han añadido \textbf{efectos especiales} como son el \textit{Postprocesamiento} y la cámara lenta. Para poder conseguir el efecto de postprocesamiento era necesario aplicar el renderizador URP anteriormente mencionado. Los efectos aplicados son los motrados en la imagen siguiente.

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm, height=12cm]{PostProcessingEffectConfig.jpg}
    \caption{Parámetros de postprocesamiento usados para efectos visuales durante el modo Ultrasónico}
\end{figure}

Con estos efectos visuales se pretende dar la sensación al jugador de que ha entrado en un modo de comportamiento distinto al normal y de esa forma indicar sin que haya texto que puede ser capaz de realizar la acción de corte.

Para conseguir el efecto de cámara lenta, se realiza mediante Script con la propiedad de Unity \textit{Time} \cite{Time}. Time es una clase incorporada que proporciona información sobre el tiempo transcurrido en el juego. Permite a los desarrolladores acceder y controlar el tiempo en su juego, lo que resulta útil para la animación, la física, las transiciones y otros aspectos relacionados con el tiempo.

Algunas de las propiedades y métodos más utilizados de la clase "Time" son:
 
\begin{itemize}    
    \item \textbf{Time.deltaTime} Proporciona la duración en segundos del fotograma anterior. Se utiliza para crear movimientos suaves y consistentes, ya que compensa las diferencias de rendimiento en diferentes plataformas.
   
    \item \textbf{Time.fixedDeltaTime}  Es similar a Time.deltaTime, pero se utiliza en el contexto de las actualizaciones físicas y es constante en cada fotograma.

    \item \textbf{Time.timeScale}  Permite ajustar la velocidad del tiempo en el juego. Un valor de 1.0 significa tiempo normal, mientras que un valor menor ralentiza el tiempo y un valor mayor lo acelera.

    \item \textbf{Time.time} Representa el tiempo transcurrido en segundos desde que se inició el juego. Se utiliza para realizar cálculos basados en el tiempo, como animaciones o temporizadores.
\end{itemize}

Por tanto, la propiedad usada para hacer el efecto de cámara lenta es usar \textbf{Time.timeScale} y asignarle un valor menor que 1.

\subsubsection{Generación procedural del mapa y sus elementos}

\subsubsection{ToonShading}

\subsection{Bocetos del diseño del proyecto}
